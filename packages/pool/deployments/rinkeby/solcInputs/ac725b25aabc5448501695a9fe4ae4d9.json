{
  "language": "Solidity",
  "sources": {
    "contracts/Api3Pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./TimelockUtils.sol\";\nimport \"./interfaces/IApi3Pool.sol\";\n\n/// @title API3 pool contract\n/// @notice Users can stake API3 tokens at the pool contract to be granted\n/// shares. These shares are exposed to the Aragon-based DAO with a MiniMe\n/// token interface, giving the user voting power at the DAO. Staking pays out\n/// weekly rewards that get unlocked after a year, and staked funds are used to\n/// collateralize an insurance product that is outside the scope of this\n/// contract.\n/// @dev Functionalities of the contract are distributed to files that form a\n/// chain of inheritance:\n/// (1) Api3Pool.sol\n/// (2) TimelockUtils.sol\n/// (3) ClaimUtils.sol\n/// (4) StakeUtils.sol\n/// (5) TransferUtils.sol\n/// (6) DelegationUtils.sol\n/// (7) RewardUtils.sol\n/// (8) GetterUtils.sol\n/// (9) StateUtils.sol\ncontract Api3Pool is TimelockUtils, IApi3Pool {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        TimelockUtils(api3TokenAddress)\n    {}\n}\n"
    },
    "contracts/TimelockUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./ClaimUtils.sol\";\nimport \"./interfaces/ITimelockUtils.sol\";\n\n/// @title Contract that implements vesting functionality\n/// @dev TimelockManager contracts interface with this contract to transfer\n/// API3 tokens that are locked under a vesting schedule.\ncontract TimelockUtils is ClaimUtils, ITimelockUtils {\n    struct Timelock\n    {\n        uint256 totalAmount;\n        uint256 remainingAmount;\n        uint256 releaseStart;\n        uint256 releaseEnd;\n    }\n\n    /// @notice Maps user addresses to TimelockManager contract addresses to \n    /// timelocks\n    /// @dev This implies that a user cannot have multiple timelocks\n    /// transferrerd from the same TimelockManager contract. This is\n    /// acceptable, because the TimelockManager is implemented in a way to not\n    /// allow multiple timelocks per user.\n    mapping(address => mapping(address => Timelock)) public userToDepositorToTimelock;\n\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        ClaimUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called by TimelockManager contracts to deposit tokens on behalf\n    /// of a user on a linear vesting schedule\n    /// @dev Refer to `TimelockManager.sol` to see how this is used\n    /// @param source Token source\n    /// @param amount Token amount\n    /// @param userAddress Address of the user who will receive the tokens\n    /// @param releaseStart Vesting schedule starting time\n    /// @param releaseEnd Vesting schedule ending time\n    function depositWithVesting(\n        address source,\n        uint256 amount,\n        address userAddress,\n        uint256 releaseStart,\n        uint256 releaseEnd\n        )\n        external\n        override\n    {\n        require(userToDepositorToTimelock[userAddress][msg.sender].remainingAmount == 0, ERROR_UNAUTHORIZED);\n        require(\n            releaseEnd > releaseStart\n                && amount != 0,\n            ERROR_VALUE\n            );\n        users[userAddress].unstaked = users[userAddress].unstaked + amount;\n        users[userAddress].vesting = users[userAddress].vesting + amount;\n        userToDepositorToTimelock[userAddress][msg.sender] = Timelock({\n            totalAmount: amount,\n            remainingAmount: amount,\n            releaseStart: releaseStart,\n            releaseEnd: releaseEnd\n            });\n        api3Token.transferFrom(source, address(this), amount);\n        emit DepositedVesting(\n            userAddress,\n            amount,\n            releaseStart,\n            releaseEnd\n            );\n    }\n\n    /// @notice Called to release tokens vested by the timelock\n    /// @param userAddress Address of the user whose timelock status will be\n    /// updated\n    /// @param timelockManagerAddress Address of the TimelockManager that has\n    /// created the timelock\n    function updateTimelockStatus(\n        address userAddress,\n        address timelockManagerAddress\n        )\n        external\n        override\n    {\n        Timelock storage timelock = userToDepositorToTimelock[userAddress][timelockManagerAddress];\n        require(block.timestamp > timelock.releaseStart, ERROR_UNAUTHORIZED);\n        require(timelock.remainingAmount > 0, ERROR_UNAUTHORIZED);\n        uint256 totalUnlocked;\n        if (block.timestamp >= timelock.releaseEnd)\n        {\n            totalUnlocked = timelock.totalAmount;\n        }\n        else\n        {\n            uint256 passedTime = block.timestamp - timelock.releaseStart;\n            uint256 totalTime = timelock.releaseEnd - timelock.releaseStart;\n            totalUnlocked = timelock.totalAmount * passedTime / totalTime;\n        }\n        uint256 previouslyUnlocked = timelock.totalAmount - timelock.remainingAmount;\n        uint256 newlyUnlocked = totalUnlocked - previouslyUnlocked;\n        User storage user = users[userAddress];\n        user.vesting = user.vesting - newlyUnlocked;\n        uint256 newRemainingAmount = timelock.remainingAmount - newlyUnlocked;\n        userToDepositorToTimelock[userAddress][timelockManagerAddress].remainingAmount = newRemainingAmount;\n        emit UpdatedTimelock(\n            userAddress,\n            timelockManagerAddress,\n            newRemainingAmount\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IApi3Pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./ITimelockUtils.sol\";\n\ninterface IApi3Pool is ITimelockUtils {\n}\n"
    },
    "contracts/ClaimUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./StakeUtils.sol\";\nimport \"./interfaces/IClaimUtils.sol\";\n\n/// @title Contract that implements the insurance claim payout functionality\ncontract ClaimUtils is StakeUtils, IClaimUtils {\n    /// @dev Reverts if the caller is not a claims manager\n    modifier onlyClaimsManager() {\n        require(claimsManagerStatus[msg.sender], ERROR_UNAUTHORIZED);\n        _;\n    }\n\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        StakeUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called by a claims manager to pay out an insurance claim\n    /// @dev The claims manager is a trusted contract that is allowed to\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\n    /// claims. Any kind of limiting logic (e.g., maximum amount of tokens that\n    /// can be withdrawn) is implemented at its end and is out of the scope of\n    /// this contract.\n    /// This will revert if the pool does not have enough funds.\n    /// @param recipient Recipient of the claim\n    /// @param amount Amount of tokens that will be paid out\n    function payOutClaim(\n        address recipient,\n        uint256 amount\n        )\n        external\n        override\n        onlyClaimsManager()\n    {\n        payReward();\n        // totalStake should not go lower than 1\n        require(totalStake > amount, ERROR_VALUE);\n        totalStake = totalStake - amount;\n        api3Token.transfer(recipient, amount);\n        emit PaidOutClaim(\n            recipient,\n            amount\n            );\n    }\n}\n"
    },
    "contracts/interfaces/ITimelockUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IClaimUtils.sol\";\n\ninterface ITimelockUtils is IClaimUtils {\n    event DepositedVesting(\n        address indexed user,\n        uint256 amount,\n        uint256 start,\n        uint256 end\n        );\n\n    event UpdatedTimelock(\n        address indexed user,\n        address indexed timelockManagerAddress,\n        uint256 remainingAmount\n        );\n\n    function depositWithVesting(\n        address source,\n        uint256 amount,\n        address userAddress,\n        uint256 releaseStart,\n        uint256 releaseEnd\n        )\n        external;\n\n    function updateTimelockStatus(\n        address userAddress,\n        address timelockManagerAddress\n        )\n        external;\n}\n"
    },
    "contracts/StakeUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./TransferUtils.sol\";\nimport \"./interfaces/IStakeUtils.sol\";\n\n/// @title Contract that implements staking functionality\ncontract StakeUtils is TransferUtils, IStakeUtils {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        TransferUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called to stake tokens to receive pools in the share\n    /// @param amount Amount of tokens to stake\n    function stake(uint256 amount)\n        public\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        require(user.unstaked >= amount, ERROR_VALUE);\n        user.unstaked = user.unstaked - amount;\n        uint256 totalSharesNow = totalShares();\n        uint256 sharesToMint = totalSharesNow * amount / totalStake;\n        uint256 userSharesNow = userShares(msg.sender);\n        user.shares.push(Checkpoint({\n            fromBlock: block.number,\n            value: userSharesNow + sharesToMint\n            }));\n        uint256 totalSharesAfter = totalSharesNow + sharesToMint; \n        updateTotalShares(totalSharesAfter);\n        totalStake = totalStake + amount;\n        updateDelegatedVotingPower(sharesToMint, true);\n        emit Staked(\n            msg.sender,\n            amount,\n            totalSharesAfter\n            );\n    }\n\n    /// @notice Convenience method to deposit and stake in a single transaction\n    /// @dev Due to the `deposit()` interface, `userAddress` can only be the\n    /// caller\n    /// @param source Token transfer source\n    /// @param amount Amount to be deposited and staked\n    /// @param userAddress User that the tokens will be staked for\n    function depositAndStake(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        external\n        override\n    {\n        require(userAddress == msg.sender, ERROR_UNAUTHORIZED);\n        deposit(source, amount, userAddress);\n        stake(amount);\n    }\n\n    /// @notice Called to schedule an unstake by the user\n    /// @dev Users need to schedule an unstake and wait for `unstakeWaitPeriod`\n    /// to be able to unstake.\n    /// @param amount Amount of tokens for which the unstake will be scheduled\n    /// for \n    function scheduleUnstake(uint256 amount)\n        external\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        uint256 userSharesNow = userShares(msg.sender);\n        uint256 userStakedNow = userSharesNow * totalStake / totalShares();\n        require(\n            userStakedNow >= amount,\n            ERROR_VALUE\n            );\n        user.unstakeScheduledFor = block.timestamp + unstakeWaitPeriod;\n        user.unstakeAmount = amount;\n        emit ScheduledUnstake(\n            msg.sender,\n            amount,\n            user.unstakeScheduledFor\n            );\n    }\n\n    /// @notice Called to execute a pre-scheduled unstake\n    /// @return Amount of tokens that are unstaked\n    function unstake()\n        public\n        override\n        returns(uint256)\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        require(block.timestamp > user.unstakeScheduledFor, ERROR_UNAUTHORIZED);\n        require(block.timestamp < user.unstakeScheduledFor + EPOCH_LENGTH, ERROR_UNAUTHORIZED);\n        uint256 amount = user.unstakeAmount;\n        uint256 totalSharesNow = totalShares();\n        uint256 userSharesNow = userShares(msg.sender);\n        uint256 sharesToBurn = totalSharesNow * amount / totalStake;\n        // If the user no longer has enough shares to unstake the scheduled\n        // amount of tokens, unstake as many tokens as possible instead\n        if (sharesToBurn > userSharesNow)\n        {\n            sharesToBurn = userSharesNow;\n            amount = sharesToBurn * totalStake / totalSharesNow;\n        }\n        user.unstaked = user.unstaked + amount;\n        user.shares.push(Checkpoint({\n            fromBlock: block.number,\n            value: userSharesNow - sharesToBurn\n            }));\n        uint256 totalSharesAfter = totalSharesNow > sharesToBurn\n                ? totalSharesNow - sharesToBurn\n                : 1;\n        updateTotalShares(totalSharesAfter);\n        updateDelegatedVotingPower(sharesToBurn, false);\n\n        totalStake = totalStake > amount\n            ? totalStake - amount\n            : 1;\n        user.unstakeScheduledFor = 0;\n        user.unstakeAmount = 0;\n        emit Unstaked(\n            msg.sender,\n            amount,\n            totalSharesAfter\n            );\n        return amount;\n    }\n\n    /// @notice Convenience method to execute an unstake and withdraw in a\n    /// single transaction\n    /// @dev Note that withdraw may revert because the user may have less than\n    /// `unstaked` tokens that are withdrawable\n    /// @param destination Token transfer destination\n    function unstakeAndWithdraw(address destination)\n        external\n        override\n    {\n        uint256 unstaked = unstake();\n        withdraw(destination, unstaked);\n    }\n}\n"
    },
    "contracts/interfaces/IClaimUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IStakeUtils.sol\";\n\ninterface IClaimUtils is IStakeUtils {\n    event PaidOutClaim(\n        address indexed recipient,\n        uint256 amount\n        );\n\n    function payOutClaim(\n        address recipient,\n        uint256 amount\n        )\n        external;\n}\n"
    },
    "contracts/TransferUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./DelegationUtils.sol\";\nimport \"./interfaces/ITransferUtils.sol\";\n\n/// @title Contract that implements token transfer functionality\ncontract TransferUtils is DelegationUtils, ITransferUtils {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        DelegationUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called to deposit tokens for a user by using `transferFrom()`\n    /// @dev This method is used by `TimelockManager.sol`\n    /// @param source Token transfer source\n    /// @param amount Amount to be deposited\n    /// @param userAddress User that the tokens will be deposited for\n    function deposit(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        public\n        override\n    {\n        payReward();\n        users[userAddress].unstaked = users[userAddress].unstaked + amount;\n        api3Token.transferFrom(source, address(this), amount);\n        emit Deposited(\n            userAddress,\n            amount\n            );\n    }\n\n    /// @notice Called to withdraw tokens\n    /// @dev The user should call `getUserLocked()` beforehand to ensure that\n    /// they have at least `amount` unlocked tokens to withdraw\n    /// @param destination Token transfer destination\n    /// @param amount Amount to be withdrawn\n    function withdraw(\n        address destination,\n        uint256 amount\n        )\n        public\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        uint256 userLocked = getUserLocked(msg.sender);\n        // Check if the user has `amount` unlocked tokens to withdraw\n        uint256 lockedAndVesting = userLocked + user.vesting;\n        uint256 userTotalFunds = user.unstaked + userStake(msg.sender);\n        require(userTotalFunds >= lockedAndVesting + amount, ERROR_VALUE);\n        // Carry on with the withdrawal\n        require(user.unstaked >= amount, ERROR_VALUE);\n        user.unstaked = user.unstaked - amount;\n        api3Token.transfer(destination, amount);\n        emit Withdrawn(msg.sender,\n            destination,\n            amount\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IStakeUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./ITransferUtils.sol\";\n\ninterface IStakeUtils is ITransferUtils{\n    event Staked(\n        address indexed user,\n        uint256 amount,\n        uint256 totalShares\n        );\n\n    event ScheduledUnstake(\n        address indexed user,\n        uint256 amount,\n        uint256 scheduledFor\n        );\n\n    event Unstaked(\n        address indexed user,\n        uint256 amount,\n        uint256 totalShares\n        );\n\n    function stake(uint256 amount)\n        external;\n\n    function depositAndStake(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        external;\n\n    function scheduleUnstake(uint256 amount)\n        external;\n\n    function unstake()\n        external\n        returns(uint256);\n\n    function unstakeAndWithdraw(address destination)\n        external;\n}\n"
    },
    "contracts/DelegationUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./RewardUtils.sol\";\nimport \"./interfaces/IDelegationUtils.sol\";\n\n/// @title Contract that implements voting power delegation\ncontract DelegationUtils is RewardUtils, IDelegationUtils {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        RewardUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called by the user to delegate voting power\n    /// @param delegate User address the voting power will be delegated to\n    function delegateVotingPower(address delegate) \n        external\n        override\n    {\n        payReward();\n        // Delegating users have cannot use their voting power, so we are\n        // verifying that the delegate is not currently delegating. However,\n        // the delegate may delegate after they have been delegated to.\n        require(\n            delegate != address(0)\n                && delegate != msg.sender\n                && userDelegate(delegate) == address(0),\n            ERROR_ADDRESS\n            );\n        User storage user = users[msg.sender];\n        // Do not allow frequent delegation updates as that can be used to spam\n        // proposals\n        require(\n            user.lastDelegationUpdateTimestamp <= block.timestamp - EPOCH_LENGTH,\n            ERROR_UNAUTHORIZED\n            );\n        user.lastDelegationUpdateTimestamp = block.timestamp;\n        uint256 userShares = userShares(msg.sender);\n        address userDelegate = userDelegate(msg.sender);\n\n        require(userDelegate != delegate, ERROR_DELEGATE);\n\n        if (userDelegate != address(0)) {\n            // Need to revoke previous delegation\n            updateCheckpointArray(\n                users[userDelegate].delegatedTo,\n                userReceivedDelegation(userDelegate) - userShares\n                );\n        }\n        // Assign the new delegation\n        User storage _delegate = users[delegate];\n        updateCheckpointArray(\n            _delegate.delegatedTo,\n            userReceivedDelegation(delegate) + userShares\n            );\n        // Record the new delegate for the user\n        updateAddressCheckpointArray(\n            user.delegates,\n            delegate\n            );\n        emit Delegated(\n            msg.sender,\n            delegate\n            );\n    }\n\n    /// @notice Called by the user to undelegate voting power\n    function undelegateVotingPower()\n        external\n        override\n    {\n        payReward();\n        User storage user = users[msg.sender];\n        address userDelegate = userDelegate(msg.sender);\n        require(\n            userDelegate != address(0)\n                && user.lastDelegationUpdateTimestamp <= block.timestamp - EPOCH_LENGTH,\n            ERROR_UNAUTHORIZED\n            );\n\n        uint256 userShares = userShares(msg.sender);\n        User storage delegate = users[userDelegate];\n        updateCheckpointArray(\n            delegate.delegatedTo,\n            userReceivedDelegation(userDelegate) - userShares\n            );\n        updateAddressCheckpointArray(\n            user.delegates,\n            address(0)\n            );\n        user.lastDelegationUpdateTimestamp = block.timestamp;\n        emit Undelegated(\n            msg.sender,\n            userDelegate\n            );\n    }\n\n    /// @notice Called internally when the user shares are updated to update\n    /// the delegated voting power\n    /// @dev User shares only get updated while staking, scheduling unstake\n    /// or unstaking\n    /// @param shares Amount of shares that will be added/removed\n    /// @param delta Whether the shares will be added/removed (add for `true`,\n    /// and vice versa)\n    function updateDelegatedVotingPower(\n        uint256 shares,\n        bool delta\n        )\n        internal\n    {\n        address userDelegate = userDelegate(msg.sender);\n        if (userDelegate == address(0)) {\n            return;\n        }\n\n        User storage delegate = users[userDelegate];\n        uint256 currentlyDelegatedTo = userReceivedDelegation(userDelegate);\n        uint256 newDelegatedTo;\n        if (delta) {\n            newDelegatedTo = currentlyDelegatedTo + shares;\n        } else {\n            newDelegatedTo = currentlyDelegatedTo > shares \n                ? currentlyDelegatedTo - shares\n                : 0;\n        }\n        updateCheckpointArray(\n            delegate.delegatedTo,\n            newDelegatedTo\n            );\n    }\n}\n"
    },
    "contracts/interfaces/ITransferUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IDelegationUtils.sol\";\n\ninterface ITransferUtils is IDelegationUtils{\n    event Deposited(\n        address indexed user,\n        uint256 amount\n        );\n\n    event Withdrawn(\n        address indexed user,\n        address indexed destination,\n        uint256 amount\n        );\n\n    function deposit(\n        address source,\n        uint256 amount,\n        address userAddress\n        )\n        external;\n\n    function withdraw(\n        address destination,\n        uint256 amount\n        )\n        external;\n}\n"
    },
    "contracts/RewardUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./GetterUtils.sol\";\nimport \"./interfaces/IRewardUtils.sol\";\n\n/// @title Contract that implements reward payments and locks\ncontract RewardUtils is GetterUtils, IRewardUtils {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        GetterUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called to pay the reward for the current epoch\n    /// @dev Skips past epochs for which rewards have not been paid for.\n    /// Skips the reward payment if the pool is not authorized to mint tokens.\n    /// Neither of these conditions will occur in practice.\n    function payReward()\n        public\n        override\n    {\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        // This will be skipped in most cases because someone else will have\n        // triggered the payment for this epoch\n        if (epochIndexOfLastRewardPayment < currentEpoch)\n        {\n            if (api3Token.getMinterStatus(address(this)))\n            {\n                updateCurrentApr();\n                uint256 rewardAmount = totalStake * currentApr / REWARD_VESTING_PERIOD / HUNDRED_PERCENT;\n                epochIndexToReward[currentEpoch] = Reward({\n                    atBlock: block.number,\n                    amount: rewardAmount,\n                    totalSharesThen: totalShares()\n                    });\n                api3Token.mint(address(this), rewardAmount);\n                totalStake = totalStake + rewardAmount;\n                emit PaidReward(\n                    currentEpoch,\n                    rewardAmount,\n                    currentApr\n                    );\n            }\n            epochIndexOfLastRewardPayment = currentEpoch;\n        }\n    }\n\n    /// @notice Updates the current APR\n    /// @dev Called internally before paying out the reward\n    function updateCurrentApr()\n        internal\n    {\n        if (stakeTarget == 0) {\n            currentApr = minApr;\n            return;\n        }\n        uint256 totalStakePercentage = totalStake\n             * HUNDRED_PERCENT\n            / api3Token.totalSupply();\n        // Calculate what % we are off from the target\n        uint256 deltaAbsolute = totalStakePercentage < stakeTarget \n            ? stakeTarget - totalStakePercentage\n            : totalStakePercentage - stakeTarget;\n        uint256 deltaPercentage = deltaAbsolute * HUNDRED_PERCENT / stakeTarget;\n        // Use the update coefficient to calculate what % we need to update\n        // the APR with\n        uint256 aprUpdate = deltaPercentage * aprUpdateCoefficient / ONE_PERCENT;\n\n        uint256 newApr;\n        if (totalStakePercentage < stakeTarget) {\n            newApr = currentApr * (HUNDRED_PERCENT + aprUpdate) / HUNDRED_PERCENT;\n        }\n        else {\n            newApr = HUNDRED_PERCENT > aprUpdate\n                ? currentApr * (HUNDRED_PERCENT - aprUpdate) / HUNDRED_PERCENT\n                : 0;\n        }\n\n        if (newApr < minApr) {\n            currentApr = minApr;\n        }\n        else if (newApr > maxApr) {\n            currentApr = maxApr;\n        }\n        else {\n            currentApr = newApr;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDelegationUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IRewardUtils.sol\";\n\ninterface IDelegationUtils is IRewardUtils {\n    event Delegated(\n        address indexed user,\n        address indexed delegate\n        );\n\n    event Undelegated(\n        address indexed user,\n        address indexed delegate\n        );\n\n    function delegateVotingPower(address delegate) \n        external;\n\n    function undelegateVotingPower()\n        external;\n\n    \n}\n"
    },
    "contracts/GetterUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./StateUtils.sol\";\nimport \"./interfaces/IGetterUtils.sol\";\n\n/// @title Contract that implements getters\ncontract GetterUtils is StateUtils, IGetterUtils {\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n        StateUtils(api3TokenAddress)\n    {}\n\n    /// @notice Called to get the voting power of a user at a specific block\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Voting power of the user at the block\n    function balanceOfAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        // Users that delegate have no voting power\n        if (userDelegateAt(userAddress, _block) != address(0))\n        {\n            return 0;\n        }\n        uint256 userSharesThen = userSharesAt(userAddress, _block);\n        uint256 delegatedToUserThen = userReceivedDelegationAt(userAddress, _block);\n        return userSharesThen + delegatedToUserThen;\n    }\n\n    /// @notice Called to get the current voting power of a user\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @param userAddress User address\n    /// @return Current voting power of the user\n    function balanceOf(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return balanceOfAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the total voting power one block ago\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Api3Voting app\n    /// @return Total voting power one block ago\n    function totalSupplyOneBlockAgo()\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return totalSharesOneBlockAgo();\n    }\n\n    /// @notice Called to get the current total voting power\n    /// @dev This method is used to implement the MiniMe interface for the\n    /// Aragon Voting app\n    /// @return Current total voting power\n    function totalSupply()\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return totalShares();\n    }\n\n    /// @notice Called to get the pool shares of a user at a specific block\n    /// @dev Starts from the most recent value in `user.shares` and searches\n    /// backwards one element at a time\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Pool shares of the user at the block\n    function userSharesAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return getValueAt(users[userAddress].shares, _block, 0);\n    }\n\n    /// @notice Called to get the current pool shares of a user\n    /// @param userAddress User address\n    /// @return Current pool shares of the user\n    function userShares(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return userSharesAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the pool shares of a user at a specific block\n    /// using binary search\n    /// @dev From \n    /// https://github.com/aragon/minime/blob/1d5251fc88eee5024ff318d95bc9f4c5de130430/contracts/MiniMeToken.sol#L431\n    /// This method is not used by the current iteration of the DAO/pool and is\n    /// implemented for future external contracts to use to get the user shares\n    /// at an arbitrary block.\n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Pool shares of the user at the block\n    function userSharesAtWithBinarySearch(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        override\n        returns(uint256)\n    {\n        Checkpoint[] storage checkpoints = users[userAddress].shares;\n        if (checkpoints.length == 0)\n            return 0;\n\n        // Shortcut for the actual value\n        if (_block >= checkpoints[checkpoints.length -1].fromBlock)\n            return checkpoints[checkpoints.length - 1].value;\n        if (_block < checkpoints[0].fromBlock)\n            return 0;\n\n        // Binary search of the value in the array\n        uint min = 0;\n        uint max = checkpoints.length - 1;\n        while (max > min) {\n            uint mid = (max + min + 1) / 2;\n            if (checkpoints[mid].fromBlock <= _block) {\n                min = mid;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return checkpoints[min].value;\n    }\n\n    /// @notice Called to get the current staked tokens of the user\n    /// @param userAddress User address\n    /// @return Current staked tokens of the user\n    function userStake(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return userShares(userAddress) * totalStake / totalShares();\n    }\n\n    /// @notice Called to get the voting power delegated to a user at a\n    /// specific block\n    /// @dev Starts from the most recent value in `user.delegatedTo` and\n    /// searches backwards one element at a time. If `_block` is within\n    /// `EPOCH_LENGTH`, this call is guaranteed to find the value among\n    /// the last `MAX_INTERACTION_FREQUENCY` elements, which is why it only\n    /// searches through them. \n    /// @param userAddress User address\n    /// @param _block Block number for which the query is being made for\n    /// @return Voting power delegated to the user at the block\n    function userReceivedDelegationAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(uint256)\n    {\n        Checkpoint[] storage delegatedTo = users[userAddress].delegatedTo;\n        uint256 minimumCheckpointIndex = delegatedTo.length > MAX_INTERACTION_FREQUENCY\n            ? delegatedTo.length - MAX_INTERACTION_FREQUENCY\n            : 0;\n        return getValueAt(delegatedTo, _block, minimumCheckpointIndex);\n    }\n\n    /// @notice Called to get the current voting power delegated to a user\n    /// @param userAddress User address\n    /// @return Current voting power delegated to the user\n    function userReceivedDelegation(address userAddress)\n        public\n        view\n        override\n        returns(uint256)\n    {\n        return userReceivedDelegationAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the delegate of the user at a specific block\n    /// @dev Starts from the most recent value in `user.delegates` and\n    /// searches backwards one element at a time. If `_block` is within\n    /// `EPOCH_LENGTH`, this call is guaranteed to find the value among\n    /// the last 2 elements because a user cannot update delegate more\n    /// frequently than once an `EPOCH_LENGTH`.\n    /// @param userAddress User address\n    /// @param _block Block number\n    /// @return Delegate of the user at the specific block\n    function userDelegateAt(\n        address userAddress,\n        uint256 _block\n        )\n        public\n        view\n        override\n        returns(address)\n    {\n        AddressCheckpoint[] storage delegates = users[userAddress].delegates;\n        for (uint256 i = delegates.length; i > 0; i--)\n        {\n            if (delegates[i - 1].fromBlock <= _block)\n            {\n                return delegates[i - 1]._address;\n            }\n        }\n        return address(0);\n    }\n\n    /// @notice Called to get the current delegate of the user\n    /// @param userAddress User address\n    /// @return Current delegate of the user\n    function userDelegate(address userAddress)\n        public\n        view\n        override\n        returns(address)\n    {\n        return userDelegateAt(userAddress, block.number);\n    }\n\n    /// @notice Called to get the current locked tokens of the user\n    /// @param userAddress User address\n    /// @return locked Current locked tokens of the user\n    function getUserLocked(address userAddress)\n        public\n        view\n        override\n        returns(uint256 locked)\n    {\n        Checkpoint[] storage _userShares = users[userAddress].shares;\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        uint256 oldestLockedEpoch = currentEpoch - REWARD_VESTING_PERIOD > genesisEpoch\n            ? currentEpoch - REWARD_VESTING_PERIOD + 1\n            : genesisEpoch + 1;\n\n        if (_userShares.length == 0)\n        {\n            return 0;\n        }\n        uint256 indUserShares = _userShares.length - 1;\n        for (\n                uint256 indEpoch = currentEpoch;\n                indEpoch >= oldestLockedEpoch;\n                indEpoch--\n            )\n        {\n            Reward storage lockedReward = epochIndexToReward[indEpoch];\n            if (lockedReward.atBlock != 0)\n            {\n                for (; indUserShares >= 0; indUserShares--)\n                {\n                    Checkpoint storage userShare = _userShares[indUserShares];\n                    if (userShare.fromBlock <= lockedReward.atBlock)\n                    {\n                        locked += lockedReward.amount * userShare.value / lockedReward.totalSharesThen;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    /// @notice Called to get the value of a checkpoint array at a specific\n    /// block\n    /// @param checkpoints Checkpoints array\n    /// @param _block Block number for which the query is being made\n    /// @return Value of the checkpoint array at the block\n    function getValueAt(\n        Checkpoint[] storage checkpoints,\n        uint256 _block,\n        uint256 minimumCheckpointIndex\n        )\n        internal\n        view\n        returns(uint256)\n    {\n        uint256 i = checkpoints.length;\n        for (; i > minimumCheckpointIndex; i--)\n        {\n            if (checkpoints[i - 1].fromBlock <= _block)\n            {\n                return checkpoints[i - 1].value;\n            }\n        }\n        // Revert if the value being searched for comes before\n        // `minimumCheckpointIndex`\n        require(i == 0, ERROR_VALUE);\n        return 0;\n    }\n}\n"
    },
    "contracts/interfaces/IRewardUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IGetterUtils.sol\";\n\ninterface IRewardUtils is IGetterUtils {\n    event PaidReward(\n        uint256 indexed epoch,\n        uint256 rewardAmount,\n        uint256 apr\n        );\n\n    function payReward()\n        external;\n}\n"
    },
    "contracts/StateUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./auxiliary/interfaces/v0.8.2/IApi3Token.sol\";\nimport \"./interfaces/IStateUtils.sol\";\n\n/// @title Contract that keeps state variables\ncontract StateUtils is IStateUtils {\n    struct Checkpoint {\n        uint256 fromBlock;\n        uint256 value;\n    }\n\n    struct AddressCheckpoint {\n        uint256 fromBlock;\n        address _address;\n    }\n\n    struct Reward {\n        uint256 atBlock;\n        uint256 amount;\n        uint256 totalSharesThen;\n    }\n\n    struct User {\n        uint256 unstaked;\n        uint256 vesting;\n        Checkpoint[] shares;\n        AddressCheckpoint[] delegates;\n        Checkpoint[] delegatedTo;\n        uint256 lastDelegationUpdateTimestamp;\n        uint256 unstakeScheduledFor;\n        uint256 unstakeAmount;\n    }\n\n    /// @notice Length of the epoch in which the staking reward is paid out\n    /// once. It is hardcoded as 7 days in seconds.\n    /// @dev In addition to regulating reward payments, this variable is used\n    /// for four additional things:\n    /// (1) Once an unstaking scheduling matures, the user has `EPOCH_LENGTH`\n    /// to execute the unstaking before it expires\n    /// (2) After a user makes a proposal, they cannot make a second one\n    /// before `EPOCH_LENGTH` has passed\n    /// (3) After a user updates their delegation status, they have to wait\n    /// `EPOCH_LENGTH` before updating it again\n    /// (4) A user's `delegatedTo` or `delegates` checkpoint arrays can be\n    /// extended up to `MAX_INTERACTION_FREQUENCY` in an `EPOCH_LENGTH`\n    uint256 public constant EPOCH_LENGTH = 7 * 24 * 60 * 60;\n\n    /// @notice Number of epochs before the staking rewards get unlocked.\n    /// Hardcoded as 52 epochs, which corresponds to a year.\n    uint256 public constant REWARD_VESTING_PERIOD = 52;\n\n    /// @notice Maximum number of additions interactions can make to a specific\n    /// user's `delegatedTo` and `delegates` in an EPOCH_LENGTH before it\n    /// starts to revert\n    /// @dev Note that interactions overwrite checkpoints rather than adding a\n    /// new element to the arrays unless a new proposal is made between them.\n    /// This means that at least `MAX_INTERACTION_FREQUENCY` proposals need\n    /// to be made for this mechanism to prevent further interactions, which is\n    /// not likely to happen in practice due to the proposal spam protection\n    /// mechanisms.\n    uint256 public constant MAX_INTERACTION_FREQUENCY = 20;\n\n    string internal constant ERROR_VALUE = \"Invalid value\";\n    string internal constant ERROR_ADDRESS = \"Invalid address\";\n    string internal constant ERROR_UNAUTHORIZED = \"Unauthorized\";\n    string internal constant ERROR_FREQUENCY = \"Try again a week later\";\n    string internal constant ERROR_DELEGATE = \"Cannot delegate to the same address\";\n\n    // All percentage values are represented by multiplying by 1e6\n    uint256 internal constant ONE_PERCENT = 1_000_000;\n    uint256 internal constant HUNDRED_PERCENT = 100_000_000;\n    \n    /// @notice API3 token contract\n    IApi3Token public api3Token;\n\n    /// @notice Address of the primary Agent app of the API3 DAO\n    /// @dev Primary Agent can be operated through the primary Api3Voting app.\n    /// The primary Api3Voting app requires a higher quorum, and the primary\n    /// Agent is more privileged.\n    address public agentAppPrimary;\n\n    /// @notice Address of the secondary Agent app of the API3 DAO\n    /// @dev Secondary Agent can be operated through the secondary Api3Voting\n    /// app. The secondary Api3Voting app requires a lower quorum, and the primary\n    /// Agent is less privileged.\n    address public agentAppSecondary;\n\n    /// @notice Address of the primary Api3Voting app of the API3 DAO\n    /// @dev Used to operate the primary Agent\n    address public votingAppPrimary;\n\n    /// @notice Address of the secondary Api3Voting app of the API3 DAO\n    /// @dev Used to operate the secondary Agent\n    address public votingAppSecondary;\n\n    /// @notice Mapping that keeps the claims manager statuses of addresses\n    /// @dev A claims manager is a contract that is authorized to pay out\n    /// claims from the staking pool, effectively slashing the stakers. The\n    /// statuses are kept as a mapping to support multiple claims managers.\n    mapping(address => bool) public claimsManagerStatus;\n\n    /// @notice Epochs are indexed as `block.timestamp / EPOCH_LENGTH`.\n    /// `genesisEpoch` is the index of the epoch in which the pool is deployed.\n    uint256 public immutable genesisEpoch;\n\n    /// @notice Records of rewards paid in each epoch\n    /// @dev `.atBlock` of a past epoch's reward record being `0` means no\n    /// reward was paid for that block\n    mapping(uint256 => Reward) public epochIndexToReward;\n\n    /// @notice Epoch index of the most recent reward payment\n    uint256 public epochIndexOfLastRewardPayment;\n\n    /// @notice User records\n    mapping(address => User) public users;\n\n    /// @notice Total number of tokens staked at the pool\n    uint256 public totalStake;\n\n    /// @notice Stake target the pool will aim to meet in percentages of the\n    /// total token supply. The staking rewards increase if the total staked\n    ///  amount is below this, and vice versa.\n    /// @dev Default value is 50% of the total API3 token supply. This\n    /// parameter is governable by the DAO.\n    uint256 public stakeTarget = 50_000_000;\n\n    /// @notice Minimum APR (annual percentage rate) the pool will pay as\n    /// staking rewards in percentages\n    /// @dev Default value is 2.5%. This parameter is governable by the DAO.\n    uint256 public minApr = 2_500_000;\n\n    /// @notice Maximum APR (annual percentage rate) the pool will pay as\n    /// staking rewards in percentages\n    /// @dev Default value is 75%. This parameter is governable by the DAO.\n    uint256 public maxApr = 75_000_000;\n\n    /// @notice Coefficient that represents how aggresively the APR will be\n    /// updated to meet the stake target.\n    /// @dev Since this is a coefficient, it has no unit. A coefficient of 1e6\n    /// means 1% deviation from the stake target results in 1% update in APR.\n    /// This parameter is governable by the DAO.\n    uint256 public aprUpdateCoefficient = 1_000_000;\n\n    /// @notice Users need to schedule an unstake and wait for\n    /// `unstakeWaitPeriod` before being able to unstake. This is to prevent\n    /// the stakers from frontrunning insurance claims by unstaking to evade\n    /// them, or repeatedly unstake/stake to work around the proposal spam\n    /// protection.\n    /// @dev This parameter is governable by the DAO, and the DAO is expected\n    /// to set this to a value that is large enough to allow insurance claims\n    /// to be resolved.\n    uint256 public unstakeWaitPeriod = EPOCH_LENGTH;\n\n    /// @notice Minimum voting power the users must have to be able to make\n    /// proposals (in percentages)\n    /// @dev Delegations count towards voting power.\n    /// Default value is 0.1%. This parameter is governable by the DAO.\n    uint256 public proposalVotingPowerThreshold = 100_000;\n\n    /// @notice APR that will be paid next epoch\n    /// @dev This is initialized at maximum APR, but will reach an\n    /// equilibrium based on the stake target.\n    /// Every epoch (week), APR/52 of the total staked tokens will be added to\n    /// the pool, effectively distributing them to the stakers.\n    uint256 public currentApr = maxApr;\n\n    /// @notice Mapping that keeps the specs of a proposal provided by a user\n    /// @dev After making a proposal through the Agent app, the user publishes\n    /// the specs of the proposal (target contract address, function,\n    /// parameters) at a URL\n    mapping(address => mapping(address => mapping(uint256 => string))) public userAddressToVotingAppToProposalIndexToSpecsUrl;\n\n    // Snapshot block number of the last vote created at one of the DAO\n    // Api3Voting apps\n    uint256 private lastVoteSnapshotBlock;\n    mapping(uint256 => uint256) private snapshotBlockToTimestamp;\n\n    // We keep checkpoints for two most recent blocks at which totalShares has\n    // been updated. Note that the indices do not indicate chronological\n    // ordering.\n    Checkpoint private totalSharesCheckpoint1;\n    Checkpoint private totalSharesCheckpoint2;\n\n    /// @dev Reverts if the caller is not an API3 DAO Agent\n    modifier onlyAgentApp() {\n        require(\n            msg.sender == agentAppPrimary || msg.sender == agentAppSecondary,\n            ERROR_UNAUTHORIZED\n            );\n        _;\n    }\n\n    /// @dev Reverts if the caller is not the primary API3 DAO Agent\n    modifier onlyAgentAppPrimary() {\n        require(msg.sender == agentAppPrimary, ERROR_UNAUTHORIZED);\n        _;\n    }\n\n    /// @param api3TokenAddress API3 token contract address\n    constructor(address api3TokenAddress)\n    {\n        api3Token = IApi3Token(api3TokenAddress);\n        // Initialize the share price at 1\n        updateTotalShares(1);\n        totalStake = 1;\n        // Set the current epoch as the genesis epoch and skip its reward\n        // payment\n        uint256 currentEpoch = block.timestamp / EPOCH_LENGTH;\n        genesisEpoch = currentEpoch;\n        epochIndexOfLastRewardPayment = currentEpoch;\n    }\n\n    /// @notice Called after deployment to set the addresses of the DAO apps\n    /// @dev This can also be called later on by the primary Agent to update\n    /// all app addresses as a means of upgrade\n    /// @param _agentAppPrimary Address of the primary Agent\n    /// @param _agentAppSecondary Address of the secondary Agent\n    /// @param _votingAppPrimary Address of the primary Api3Voting\n    /// @param _votingAppSecondary Address of the secondary Api3Voting\n    function setDaoApps(\n        address _agentAppPrimary,\n        address _agentAppSecondary,\n        address _votingAppPrimary,\n        address _votingAppSecondary\n        )\n        external\n        override\n    {\n        require(\n            agentAppPrimary == address(0) || msg.sender == agentAppPrimary,\n            ERROR_UNAUTHORIZED\n            );\n        require(\n            _agentAppPrimary != address(0)\n                && _agentAppSecondary  != address(0)\n                && _votingAppPrimary  != address(0)\n                && _votingAppSecondary  != address(0),\n            ERROR_ADDRESS\n            );\n        agentAppPrimary = _agentAppPrimary;\n        agentAppSecondary = _agentAppSecondary;\n        votingAppPrimary = _votingAppPrimary;\n        votingAppSecondary = _votingAppSecondary;\n        emit SetDaoApps(\n            agentAppPrimary,\n            agentAppSecondary,\n            votingAppPrimary,\n            votingAppSecondary\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the authorization status of a\n    /// claims manager contract\n    /// @dev The claims manager is a trusted contract that is allowed to\n    /// withdraw as many tokens as it wants from the pool to pay out insurance\n    /// claims.\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @param claimsManager Claims manager contract address\n    /// @param status Authorization status\n    function setClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        )\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        claimsManagerStatus[claimsManager] = status;\n        emit SetClaimsManagerStatus(\n            claimsManager,\n            status\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the stake target\n    /// @param _stakeTarget Stake target\n    function setStakeTarget(uint256 _stakeTarget)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(\n            _stakeTarget <= HUNDRED_PERCENT\n                && _stakeTarget >= 0,\n            ERROR_VALUE);\n        uint256 oldStakeTarget = stakeTarget;\n        stakeTarget = _stakeTarget;\n        emit SetStakeTarget(\n            oldStakeTarget,\n            stakeTarget\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the maximum APR\n    /// @param _maxApr Maximum APR\n    function setMaxApr(uint256 _maxApr)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(_maxApr >= minApr, ERROR_VALUE);\n        uint256 oldMaxApr = maxApr;\n        maxApr = _maxApr;\n        emit SetMaxApr(\n            oldMaxApr,\n            maxApr\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the minimum APR\n    /// @param _minApr Minimum APR\n    function setMinApr(uint256 _minApr)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(_minApr <= maxApr, ERROR_VALUE);\n        uint256 oldMinApr = minApr;\n        minApr = _minApr;\n        emit SetMinApr(\n            oldMinApr,\n            minApr\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the unstake waiting period\n    /// @dev This may want to be increased to provide more time for insurance\n    /// claims to be resolved.\n    /// Even when the insurance functionality is not implemented, the minimum\n    /// valid value is `EPOCH_LENGTH` to prevent users from unstaking,\n    /// withdrawing and staking with another address to work around the\n    /// proposal spam protection.\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @param _unstakeWaitPeriod Unstake waiting period\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        require(_unstakeWaitPeriod >= EPOCH_LENGTH, ERROR_VALUE);\n        uint256 oldUnstakeWaitPeriod = unstakeWaitPeriod;\n        unstakeWaitPeriod = _unstakeWaitPeriod;\n        emit SetUnstakeWaitPeriod(\n            oldUnstakeWaitPeriod,\n            unstakeWaitPeriod\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the APR update coefficient\n    /// @param _aprUpdateCoefficient APR update coefficient\n    function setAprUpdateCoefficient(uint256 _aprUpdateCoefficient)\n        external\n        override\n        onlyAgentApp()\n    {\n        require(\n            _aprUpdateCoefficient <= 1_000_000_000\n                && _aprUpdateCoefficient > 0,\n            ERROR_VALUE\n            );\n        uint256 oldAprUpdateCoefficient = aprUpdateCoefficient;\n        aprUpdateCoefficient = _aprUpdateCoefficient;\n        emit SetAprUpdateCoefficient(\n            oldAprUpdateCoefficient,\n            aprUpdateCoefficient\n            );\n    }\n\n    /// @notice Called by the DAO Agent to set the voting power threshold for\n    /// proposals\n    /// Only the primary Agent can do this because it is a critical operation.\n    /// @param _proposalVotingPowerThreshold Voting power threshold for\n    /// proposals\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n        external\n        override\n        onlyAgentAppPrimary()\n    {\n        require(\n            _proposalVotingPowerThreshold <= 10 * ONE_PERCENT,\n            ERROR_VALUE);\n        uint256 oldProposalVotingPowerThreshold = proposalVotingPowerThreshold;\n        proposalVotingPowerThreshold = _proposalVotingPowerThreshold;\n        emit SetProposalVotingPowerThreshold(\n            oldProposalVotingPowerThreshold,\n            proposalVotingPowerThreshold\n            );\n    }\n\n    /// @notice Called by the owner of the proposal to publish the specs URL\n    /// @dev Since the owner of a proposal is known, users publishing specs for\n    /// a proposal that is not their own is not a concern\n    /// @param proposalIndex Proposal index\n    /// @param specsUrl URL that hosts the specs of the transaction that will\n    /// be made if the proposal passes\n    function publishSpecsUrl(\n        address votingApp,\n        uint256 proposalIndex,\n        string calldata specsUrl\n        )\n        external\n        override\n    {\n        userAddressToVotingAppToProposalIndexToSpecsUrl[msg.sender][votingApp][proposalIndex] = specsUrl;\n        emit PublishedSpecsUrl(\n            votingApp,\n            proposalIndex,\n            msg.sender,\n            specsUrl\n            );\n    }\n\n    /// @notice Called by a DAO Api3Voting app to update the last vote snapshot\n    /// block number\n    /// @param snapshotBlock Last vote snapshot block number\n    function updateLastVoteSnapshotBlock(uint256 snapshotBlock)\n        external\n        override\n    {\n        require(\n            msg.sender == votingAppPrimary || msg.sender == votingAppSecondary,\n            ERROR_UNAUTHORIZED\n            );\n        lastVoteSnapshotBlock = snapshotBlock;\n        snapshotBlockToTimestamp[snapshotBlock] = block.timestamp;\n        emit UpdatedLastVoteSnapshotBlock(\n            msg.sender,\n            snapshotBlock,\n            block.timestamp\n            );\n    }\n\n    /// @notice Called internally to update the total shares history\n    /// @dev `fromBlock0` and `fromBlock1` will be two different block numbers\n    /// when totalShares history was last updated. If one of these\n    /// `fromBlock`s match with `block.number`, we simply update the value\n    /// (because the history keeps the most recent value from that block). If\n    /// not, we can overwrite the older one, as we no longer need it.\n    /// @param newTotalShares Total shares value to insert into history\n    function updateTotalShares(uint256 newTotalShares)\n        internal\n    {\n        if (block.number == totalSharesCheckpoint1.fromBlock)\n        {\n            totalSharesCheckpoint1.value = newTotalShares;\n        }\n        else if (block.number == totalSharesCheckpoint2.fromBlock)\n        {\n            totalSharesCheckpoint2.value = newTotalShares;\n        }\n        else {\n            if (totalSharesCheckpoint1.fromBlock < totalSharesCheckpoint2.fromBlock)\n            {\n                totalSharesCheckpoint1.fromBlock = block.number;\n                totalSharesCheckpoint1.value = newTotalShares;\n            }\n            else\n            {\n                totalSharesCheckpoint2.fromBlock = block.number;\n                totalSharesCheckpoint2.value = newTotalShares;\n            }\n        }\n    }\n\n    /// @notice Called internally to get the current total shares\n    /// @return Current total shares\n    function totalShares()\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalSharesCheckpoint1.fromBlock < totalSharesCheckpoint2.fromBlock)\n        {\n            return totalSharesCheckpoint2.value;\n        }\n        else\n        {\n            return totalSharesCheckpoint1.value;\n        }\n    }\n\n    /// @notice Called internally to get the total shares one block ago\n    /// @return Total shares one block ago\n    function totalSharesOneBlockAgo()\n        internal\n        view\n        returns (uint256)\n    {\n        if (totalSharesCheckpoint2.fromBlock == block.number)\n        {\n            return totalSharesCheckpoint1.value;\n        }\n        else if (totalSharesCheckpoint1.fromBlock == block.number)\n        {\n            return totalSharesCheckpoint2.value;\n        }\n        else\n        {\n            return totalShares();\n        }\n    }\n\n    /// @notice Called internally to update a checkpoint array\n    /// @param checkpointArray Checkpoint array to be updated\n    /// @param value Value to be updated with\n    function updateCheckpointArray(\n        Checkpoint[] storage checkpointArray,\n        uint256 value\n        )\n        internal\n    {\n        if (checkpointArray.length == 0)\n        {\n            checkpointArray.push(Checkpoint({\n                fromBlock: lastVoteSnapshotBlock,\n                value: value\n                }));\n        }\n        else\n        {\n            if (checkpointArray.length + 1 >= MAX_INTERACTION_FREQUENCY)\n            {\n                uint256 interactionTimestampMaxInteractionFrequencyAgo = snapshotBlockToTimestamp[checkpointArray[checkpointArray.length + 1 - MAX_INTERACTION_FREQUENCY].fromBlock];\n                require(\n                    block.timestamp - interactionTimestampMaxInteractionFrequencyAgo > EPOCH_LENGTH,\n                    ERROR_FREQUENCY\n                    );\n            }\n            Checkpoint storage lastElement = checkpointArray[checkpointArray.length - 1];\n            if (lastElement.fromBlock < lastVoteSnapshotBlock)\n            {\n                checkpointArray.push(Checkpoint({\n                    fromBlock: lastVoteSnapshotBlock,\n                    value: value\n                    }));\n            }\n            else\n            {\n                lastElement.value = value;\n            }\n        }\n    }\n\n    /// @notice Called internally to update an address checkpoint array\n    /// @param addressCheckpointArray Address checkpoint array to be updated\n    /// @param _address Address to be updated with\n    function updateAddressCheckpointArray(\n        AddressCheckpoint[] storage addressCheckpointArray,\n        address _address\n        )\n        internal\n    {\n        if (addressCheckpointArray.length == 0)\n        {\n            addressCheckpointArray.push(AddressCheckpoint({\n                fromBlock: lastVoteSnapshotBlock,\n                _address: _address\n                }));\n        }\n        else\n        {\n            AddressCheckpoint storage lastElement = addressCheckpointArray[addressCheckpointArray.length - 1];\n            if (lastElement.fromBlock < lastVoteSnapshotBlock)\n            {\n                addressCheckpointArray.push(AddressCheckpoint({\n                    fromBlock: lastVoteSnapshotBlock,\n                    _address: _address\n                    }));\n            }\n            else\n            {\n                lastElement._address = _address;\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IGetterUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IStateUtils.sol\";\n\ninterface IGetterUtils is IStateUtils {\n    function balanceOfAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function balanceOf(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function totalSupplyOneBlockAgo()\n        external\n        view\n        returns(uint256);\n\n    function totalSupply()\n        external\n        view\n        returns(uint256);\n\n    function userSharesAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userShares(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function userSharesAtWithBinarySearch(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userStake(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function userReceivedDelegationAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(uint256);\n\n    function userReceivedDelegation(address userAddress)\n        external\n        view\n        returns(uint256);\n\n    function userDelegateAt(\n        address userAddress,\n        uint256 _block\n        )\n        external\n        view\n        returns(address);\n\n    function userDelegate(address userAddress)\n        external\n        view\n        returns(address);\n\n    function getUserLocked(address userAddress)\n        external\n        view\n        returns(uint256);\n}\n"
    },
    "contracts/auxiliary/interfaces/v0.8.2/IApi3Token.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"./IERC20.sol\";\n\ninterface IApi3Token is IERC20 {\n    event MinterStatusUpdated(\n        address indexed minterAddress,\n        bool minterStatus\n        );\n\n    event BurnerStatusUpdated(\n        address indexed burnerAddress,\n        bool burnerStatus\n        );\n\n    function updateMinterStatus(\n        address minterAddress,\n        bool minterStatus\n        )\n        external;\n\n    function updateBurnerStatus(bool burnerStatus)\n        external;\n\n    function mint(\n        address account,\n        uint256 amount\n        )\n        external;\n\n    function burn(uint256 amount)\n        external;\n\n    function getMinterStatus(address minterAddress)\n        external\n        view\n        returns(bool minterStatus);\n\n    function getBurnerStatus(address burnerAddress)\n        external\n        view\n        returns(bool burnerStatus);\n}\n"
    },
    "contracts/interfaces/IStateUtils.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\ninterface IStateUtils {\n    event SetDaoApps(\n        address agentAppPrimary,\n        address agentAppSecondary,\n        address votingAppPrimary,\n        address votingAppSecondary\n        );\n\n    event SetClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        );\n\n    event SetStakeTarget(\n        uint256 oldTarget,\n        uint256 newTarget\n        );\n\n    event SetMaxApr(\n        uint256 oldMaxApr,\n        uint256 maxApr\n        );\n\n    event SetMinApr(\n        uint256 oldMinApr,\n        uint256 minApr\n        );\n\n    event SetUnstakeWaitPeriod(\n        uint256 oldUnstakeWaitPeriod,\n        uint256 unstakeWaitPeriod\n        );\n\n    event SetAprUpdateCoefficient(\n        uint256 oldAprUpdateCoefficient,\n        uint256 aprUpdateCoefficient\n        );\n\n    event SetProposalVotingPowerThreshold(\n        uint256 oldProposalVotingPowerThreshold,\n        uint256 proposalVotingPowerThreshold\n        );\n\n    event PublishedSpecsUrl(\n        address indexed votingApp,\n        uint256 indexed proposalIndex,\n        address userAddress,\n        string specsUrl\n        );\n\n    event UpdatedLastVoteSnapshotBlock(\n        address votingApp,\n        uint256 lastVoteSnapshotBlock,\n        uint256 lastVoteSnapshotBlockUpdateTimestamp\n        );\n\n    function setDaoApps(\n        address _agentAppPrimary,\n        address _agentAppSecondary,\n        address _votingAppPrimary,\n        address _votingAppSecondary\n        )\n        external;\n\n    function setClaimsManagerStatus(\n        address claimsManager,\n        bool status\n        )\n        external;\n\n    function setStakeTarget(uint256 _stakeTarget)\n        external;\n\n    function setMaxApr(uint256 _maxApr)\n        external;\n\n    function setMinApr(uint256 _minApr)\n        external;\n\n    function setUnstakeWaitPeriod(uint256 _unstakeWaitPeriod)\n        external;\n\n    function setAprUpdateCoefficient(uint256 _aprUpdateCoefficient)\n        external;\n\n    function setProposalVotingPowerThreshold(uint256 _proposalVotingPowerThreshold)\n        external;\n\n    function publishSpecsUrl(\n        address votingApp,\n        uint256 proposalIndex,\n        string calldata specsUrl\n        )\n        external;\n\n    function updateLastVoteSnapshotBlock(uint256 snapshotBlock)\n        external;\n}\n"
    },
    "contracts/auxiliary/interfaces/v0.8.2/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/mock/MockApi3Voting.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../interfaces/IApi3Pool.sol\";\n\ncontract MockApi3Voting {\n    IApi3Pool public api3Pool;\n\n    constructor(address _api3Pool)\n    {\n        api3Pool = IApi3Pool(_api3Pool);\n    }\n\n    function newVote()\n        external\n    {\n        api3Pool.updateLastVoteSnapshotBlock(block.number - 1);\n    }\n}\n"
    },
    "contracts/mock/MockApi3Staker.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity 0.8.2;\n\nimport \"../auxiliary/interfaces/v0.8.2/IApi3Token.sol\";\nimport \"../interfaces/IApi3Pool.sol\";\n\ncontract MockApi3Staker {\n    IApi3Token public api3Token;\n    IApi3Pool public api3Pool;\n\n    constructor(\n        address _api3Token,\n        address _api3Pool\n        )\n    {\n        api3Token = IApi3Token(_api3Token);\n        api3Pool = IApi3Pool(_api3Pool);\n    }\n\n    function stakeTwice(\n        uint256 amount1,\n        uint256 amount2\n        )\n        external\n    {\n        api3Token.approve(address(api3Pool), amount1 + amount2);\n        api3Pool.depositAndStake(\n          address(this),\n          amount1,\n          address(this)\n          );\n        api3Pool.depositAndStake(\n          address(this),\n          amount2,\n          address(this)\n          );\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}